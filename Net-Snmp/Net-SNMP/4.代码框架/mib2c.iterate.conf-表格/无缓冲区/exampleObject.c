/*
 * Note: this file originally auto-generated by mib2c using
 *  $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "exampleObject.h"

/** Initializes the exampleObject module */
void
init_exampleObject(void)
{
  /* here we initialize all the tables we're planning on supporting */
    initialize_table_simpleTable();
    initialize_table_generalTable();
}

  # Determine the first/last column names

/** Initialize the simpleTable table by defining its contents and how it's structured */
void
initialize_table_simpleTable(void)   //注册表格信息
{
    const oid simpleTable_oid[] = {1,3,6,1,4,1,9999,3,9};
    const size_t simpleTable_oid_len   = OID_LENGTH(simpleTable_oid);
    netsnmp_handler_registration    *reg;
    netsnmp_iterator_info           *iinfo;
    netsnmp_table_registration_info *table_info;

    DEBUGMSGTL(("exampleObject:init", "initializing table simpleTable\n"));

    reg = netsnmp_create_handler_registration(
              "simpleTable",     simpleTable_handler,
              simpleTable_oid, simpleTable_oid_len,
              HANDLER_CAN_RWRITE
              );

    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_INTEGER,  /* index: simpleTbColum1 */
                           0);
    table_info->min_column = COLUMN_SIMPLETBCOLUM1;
    table_info->max_column = COLUMN_SIMPLETBCOLUM2;
    
    iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
    iinfo->get_first_data_point = simpleTable_get_first_data_point;
    iinfo->get_next_data_point  = simpleTable_get_next_data_point;
    iinfo->table_reginfo        = table_info;
    
    netsnmp_register_table_iterator( reg, iinfo );
    netsnmp_inject_handler_before( reg, 
        netsnmp_get_cache_handler(SIMPLETABLE_TIMEOUT,
                                  simpleTable_load, simpleTable_free,
                                  simpleTable_oid, simpleTable_oid_len),
            TABLE_ITERATOR_NAME);

    /* Initialise the contents of the table here */
}

    /* Typical data structure for a row entry */
struct simpleTable_entry {
    /* Index values */
    long simpleTbColum1;

    /* Column values */
    long simpleTbColum1;
    long simpleTbColum2;
    long old_simpleTbColum2;

    /* Illustrate using a simple linked list */
    int   valid;
    struct simpleTable_entry *next;
};

struct simpleTable_entry  *simpleTable_head;  //该链表结构体存储了真实的表格数据

/* create a new row in the (unsorted) table */
struct simpleTable_entry *
simpleTable_createEntry(
                 long  simpleTbColum1,
                ) {
    struct simpleTable_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct simpleTable_entry);
    if (!entry)
        return NULL;

    entry->simpleTbColum1 = simpleTbColum1;
    entry->next = simpleTable_head;
    simpleTable_head = entry;
    return entry;
}

/* remove a row from the table */
void
simpleTable_removeEntry( struct simpleTable_entry *entry ) {
    struct simpleTable_entry *ptr, *prev;

    if (!entry)
        return;    /* Nothing to remove */

    for ( ptr  = simpleTable_head, prev = NULL;
          ptr != NULL;
          prev = ptr, ptr = ptr->next ) {
        if ( ptr == entry )
            break;
    }
    if ( !ptr )
        return;    /* Can't find it */

    if ( prev == NULL )
        simpleTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE( entry );   /* XXX - release any other internal resources */
}

/* Example cache handling - set up linked list from a suitable file */
int
simpleTable_load( netsnmp_cache *cache, void *vmagic ) {
    FILE *fp;
    struct simpleTable_entry *this;
    char buf[STRMAX];

    /* The basic load routine template assumes that the data to
       be reported is held in a file - with one row of the file
       for each row of the table.
          If your data is available via a different API, you
       should amend this initial block (and the control of the
       'while' loop) accordingly.
          'XXX' marks where the template is incomplete and
       code will definitely need to be added. */

    fp = fopen( "/data/for/simpleTable", "r" );
    if ( !fp ) {
        return -1;
    }
    while ( fgets( buf, STRMAX, fp )) {
        this = SNMP_MALLOC_TYPEDEF( struct simpleTable_entry );
        /* XXX - Unpick 'buf' to extract the individual field values
                 and then populate the 'this' data structure with them */

        this->next = simpleTable_head;
        simpleTable_head = this;    /* Iterate helper is fine with unordered lists! */
    }
    fclose(fp);
    return 0;  /* OK */
}

void
simpleTable_free( netsnmp_cache *cache, void *vmagic ) {
    struct simpleTable_entry *this, *that;

    for ( this = simpleTable_head; this; this=that ) {
        that = this->next;
        SNMP_FREE( this );   /* XXX - release any other internal resources */
    }
    simpleTable_head = NULL;
}

/* Example iterator hook routines - using 'get_next' to do most of the work */
netsnmp_variable_list *
simpleTable_get_first_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    *my_loop_context = simpleTable_head;
    return simpleTable_get_next_data_point(my_loop_context, my_data_context,
                                    put_index_data,  mydata );
}

netsnmp_variable_list *
simpleTable_get_next_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    struct simpleTable_entry *entry = (struct simpleTable_entry *)*my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if ( entry ) {
        snmp_set_var_typed_integer( idx, ASN_INTEGER, entry->simpleTbColum1 );
        idx = idx->next_variable;
        *my_data_context = (void *)entry;
        *my_loop_context = (void *)entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}


/** handles requests for the simpleTable table */
int
simpleTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    struct simpleTable_entry          *table_entry;

    DEBUGMSGTL(("exampleObject:handler", "Processing request (%d)\n", reqinfo->mode));

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request=requests; request; request=request->next) {
            table_entry = (struct simpleTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_SIMPLETBCOLUM1:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->simpleTbColum1);
                break;
            case COLUMN_SIMPLETBCOLUM2:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->simpleTbColum2);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

        /*
         * Write-support
         */
    case MODE_SET_RESERVE1:
        for (request=requests; request; request=request->next) {
            table_entry = (struct simpleTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_SIMPLETBCOLUM2:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int( request->requestvb );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            default:
                netsnmp_set_request_error( reqinfo, request,
                                           SNMP_ERR_NOTWRITABLE );
                return SNMP_ERR_NOERROR;
            }
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        for (request=requests; request; request=request->next) {
            table_entry = (struct simpleTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_SIMPLETBCOLUM2:
                table_entry->old_simpleTbColum2 = table_entry->simpleTbColum2;
                table_entry->simpleTbColum2     = *request->requestvb->val.integer;
                break;
            }
        }
        break;

    case MODE_SET_UNDO:
        for (request=requests; request; request=request->next) {
            table_entry = (struct simpleTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_SIMPLETBCOLUM2:
                table_entry->simpleTbColum2     = table_entry->old_simpleTbColum2;
                table_entry->old_simpleTbColum2 = 0;
                break;
            }
        }
        break;

    case MODE_SET_COMMIT:
        break;
    }
    return SNMP_ERR_NOERROR;
}
  # Determine the first/last column names

/** Initialize the generalTable table by defining its contents and how it's structured */
void
initialize_table_generalTable(void)
{
    const oid generalTable_oid[] = {1,3,6,1,4,1,9999,3,11};
    const size_t generalTable_oid_len   = OID_LENGTH(generalTable_oid);
    netsnmp_handler_registration    *reg;
    netsnmp_iterator_info           *iinfo;
    netsnmp_table_registration_info *table_info;

    DEBUGMSGTL(("exampleObject:init", "initializing table generalTable\n"));

    reg = netsnmp_create_handler_registration(
              "generalTable",     generalTable_handler,
              generalTable_oid, generalTable_oid_len,
              HANDLER_CAN_RWRITE
              );

    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_UNSIGNED,  /* index: generalTbColum1 */
                           ASN_UNSIGNED,  /* index: generalTbColum2 */
                           0);
    table_info->min_column = COLUMN_GENERALTBCOLUM1;
    table_info->max_column = COLUMN_GENERALTBCOLUM4;
    
    iinfo = SNMP_MALLOC_TYPEDEF( netsnmp_iterator_info );
    iinfo->get_first_data_point = generalTable_get_first_data_point;
    iinfo->get_next_data_point  = generalTable_get_next_data_point;
    iinfo->table_reginfo        = table_info;
    
    netsnmp_register_table_iterator( reg, iinfo );
    netsnmp_inject_handler_before( reg, 
        netsnmp_get_cache_handler(GENERALTABLE_TIMEOUT,
                                  generalTable_load, generalTable_free,
                                  generalTable_oid, generalTable_oid_len),
            TABLE_ITERATOR_NAME);

    /* Initialise the contents of the table here */
}

    /* Typical data structure for a row entry */
struct generalTable_entry {
    /* Index values */
    u_long generalTbColum1;
    u_long generalTbColum2;

    /* Column values */
    u_long generalTbColum1;
    u_long generalTbColum2;
    char generalTbColum3[NNN];
    size_t generalTbColum3_len;
    char old_generalTbColum3[NNN];
    size_t old_generalTbColum3_len;
    long generalTbColum4;
    long old_generalTbColum4;

    /* Illustrate using a simple linked list */
    int   valid;
    struct generalTable_entry *next;
};

struct generalTable_entry  *generalTable_head;

/* create a new row in the (unsorted) table */
struct generalTable_entry *
generalTable_createEntry(
                 u_long  generalTbColum1,
                 u_long  generalTbColum2,
                ) {
    struct generalTable_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct generalTable_entry);
    if (!entry)
        return NULL;

    entry->generalTbColum1 = generalTbColum1;
    entry->generalTbColum2 = generalTbColum2;
    entry->next = generalTable_head;
    generalTable_head = entry;
    return entry;
}

/* remove a row from the table */
void
generalTable_removeEntry( struct generalTable_entry *entry ) {
    struct generalTable_entry *ptr, *prev;

    if (!entry)
        return;    /* Nothing to remove */

    for ( ptr  = generalTable_head, prev = NULL;
          ptr != NULL;
          prev = ptr, ptr = ptr->next ) {
        if ( ptr == entry )
            break;
    }
    if ( !ptr )
        return;    /* Can't find it */

    if ( prev == NULL )
        generalTable_head = ptr->next;
    else
        prev->next = ptr->next;

    SNMP_FREE( entry );   /* XXX - release any other internal resources */
}

/* Example cache handling - set up linked list from a suitable file */
int
generalTable_load( netsnmp_cache *cache, void *vmagic ) {
    FILE *fp;
    struct generalTable_entry *this;
    char buf[STRMAX];

    /* The basic load routine template assumes that the data to
       be reported is held in a file - with one row of the file
       for each row of the table.
          If your data is available via a different API, you
       should amend this initial block (and the control of the
       'while' loop) accordingly.
          'XXX' marks where the template is incomplete and
       code will definitely need to be added. */

    fp = fopen( "/data/for/generalTable", "r" );
    if ( !fp ) {
        return -1;
    }
    while ( fgets( buf, STRMAX, fp )) {
        this = SNMP_MALLOC_TYPEDEF( struct generalTable_entry );
        /* XXX - Unpick 'buf' to extract the individual field values
                 and then populate the 'this' data structure with them */

        this->next = generalTable_head;
        generalTable_head = this;    /* Iterate helper is fine with unordered lists! */
    }
    fclose(fp);
    return 0;  /* OK */
}

void
generalTable_free( netsnmp_cache *cache, void *vmagic ) {
    struct generalTable_entry *this, *that;

    for ( this = generalTable_head; this; this=that ) {
        that = this->next;
        SNMP_FREE( this );   /* XXX - release any other internal resources */
    }
    generalTable_head = NULL;
}

/* Example iterator hook routines - using 'get_next' to do most of the work */
netsnmp_variable_list *
generalTable_get_first_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    *my_loop_context = generalTable_head;
    return generalTable_get_next_data_point(my_loop_context, my_data_context,
                                    put_index_data,  mydata );
}

netsnmp_variable_list *
generalTable_get_next_data_point(void **my_loop_context,
                          void **my_data_context,
                          netsnmp_variable_list *put_index_data,
                          netsnmp_iterator_info *mydata)
{
    struct generalTable_entry *entry = (struct generalTable_entry *)*my_loop_context;
    netsnmp_variable_list *idx = put_index_data;

    if ( entry ) {
        snmp_set_var_typed_integer( idx, ASN_UNSIGNED, entry->generalTbColum1 );
        idx = idx->next_variable;
        snmp_set_var_typed_integer( idx, ASN_UNSIGNED, entry->generalTbColum2 );
        idx = idx->next_variable;
        *my_data_context = (void *)entry;
        *my_loop_context = (void *)entry->next;
        return put_index_data;
    } else {
        return NULL;
    }
}


/** handles requests for the generalTable table */
int
generalTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    struct generalTable_entry          *table_entry;

    DEBUGMSGTL(("exampleObject:handler", "Processing request (%d)\n", reqinfo->mode));

    switch (reqinfo->mode) {
        /*
         * Read-support (also covers GetNext requests)
         */
    case MODE_GET:
        for (request=requests; request; request=request->next) {
            table_entry = (struct generalTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_GENERALTBCOLUM1:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_UNSIGNED,
                                            table_entry->generalTbColum1);
                break;
            case COLUMN_GENERALTBCOLUM2:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_UNSIGNED,
                                            table_entry->generalTbColum2);
                break;
            case COLUMN_GENERALTBCOLUM3:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          table_entry->generalTbColum3,
                                          table_entry->generalTbColum3_len);
                break;
            case COLUMN_GENERALTBCOLUM4:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->generalTbColum4);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

        /*
         * Write-support
         */
    case MODE_SET_RESERVE1:
        for (request=requests; request; request=request->next) {
            table_entry = (struct generalTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_GENERALTBCOLUM3:
	        /* or possibly 'netsnmp_check_vb_type_and_size' */
                ret = netsnmp_check_vb_type_and_max_size(
                          request->requestvb, ASN_OCTET_STR, sizeof(table_entry->generalTbColum3));
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_GENERALTBCOLUM4:
                /* or possibly 'netsnmp_check_vb_int_range' */
                ret = netsnmp_check_vb_int( request->requestvb );
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            default:
                netsnmp_set_request_error( reqinfo, request,
                                           SNMP_ERR_NOTWRITABLE );
                return SNMP_ERR_NOERROR;
            }
        }
        break;

    case MODE_SET_RESERVE2:
        break;

    case MODE_SET_FREE:
        break;

    case MODE_SET_ACTION:
        for (request=requests; request; request=request->next) {
            table_entry = (struct generalTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_GENERALTBCOLUM3:
                memcpy( table_entry->old_generalTbColum3,
                        table_entry->generalTbColum3,
                        sizeof(table_entry->generalTbColum3));
                table_entry->old_generalTbColum3_len =
                        table_entry->generalTbColum3_len;
                memset( table_entry->generalTbColum3, 0,
                        sizeof(table_entry->generalTbColum3));
                memcpy( table_entry->generalTbColum3,
                        request->requestvb->val.string,
                        request->requestvb->val_len);
                table_entry->generalTbColum3_len =
                        request->requestvb->val_len;
                break;
            case COLUMN_GENERALTBCOLUM4:
                table_entry->old_generalTbColum4 = table_entry->generalTbColum4;
                table_entry->generalTbColum4     = *request->requestvb->val.integer;
                break;
            }
        }
        break;

    case MODE_SET_UNDO:
        for (request=requests; request; request=request->next) {
            table_entry = (struct generalTable_entry *)
                              netsnmp_extract_iterator_context(request);
            table_info  =     netsnmp_extract_table_info(      request);
    
            switch (table_info->colnum) {
            case COLUMN_GENERALTBCOLUM3:
                memcpy( table_entry->generalTbColum3,
                        table_entry->old_generalTbColum3,
                        sizeof(table_entry->generalTbColum3));
                memset( table_entry->old_generalTbColum3, 0,
                        sizeof(table_entry->generalTbColum3));
                table_entry->generalTbColum3_len =
                        table_entry->old_generalTbColum3_len;
                break;
            case COLUMN_GENERALTBCOLUM4:
                table_entry->generalTbColum4     = table_entry->old_generalTbColum4;
                table_entry->old_generalTbColum4 = 0;
                break;
            }
        }
        break;

    case MODE_SET_COMMIT:
        break;
    }
    return SNMP_ERR_NOERROR;
}

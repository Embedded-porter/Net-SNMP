/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "exampleObject.h"

/* 
 * exampleObject_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid exampleObject_variables_oid[] = { 1,3,6,1,4,1,9999,3 };

/* 
 * variable4 exampleObject_variables:
 *   this variable defines function callbacks and type return information 
 *   for the exampleObject mib section 
 */

struct variable4 exampleObject_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define EXAMPLEOBJECT1		1
{EXAMPLEOBJECT1,  ASN_INTEGER,  NETSNMP_OLDAPI_RONLY,
 var_exampleObject, 1,  { 1 }},
#define EXAMPLEOBJECT2		2
{EXAMPLEOBJECT2,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_exampleObject, 1,  { 2 }},
#define EXAMPLEOBJECT3		3
{EXAMPLEOBJECT3,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_exampleObject, 1,  { 3 }},
#define EXAMPLEOBJECT4		4
{EXAMPLEOBJECT4,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_exampleObject, 1,  { 4 }},

#define SIMPLETBCOLUM1		1
{SIMPLETBCOLUM1,  ASN_INTEGER,  NETSNMP_OLDAPI_RONLY,
 var_simpleTable, 3,  { 9 , 1, 1 }},
#define SIMPLETBCOLUM2		2
{SIMPLETBCOLUM2,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_simpleTable, 3,  { 9 , 1, 2 }},
#define GENERALTBCOLUM1		1
{GENERALTBCOLUM1,  ASN_UNSIGNED,  NETSNMP_OLDAPI_RONLY,
 var_generalTable, 3,  { 11 , 1, 1 }},
#define GENERALTBCOLUM2		2
{GENERALTBCOLUM2,  ASN_UNSIGNED,  NETSNMP_OLDAPI_RONLY,
 var_generalTable, 3,  { 11 , 1, 2 }},
#define GENERALTBCOLUM3		3
{GENERALTBCOLUM3,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,
 var_generalTable, 3,  { 11 , 1, 3 }},
#define GENERALTBCOLUM4		4
{GENERALTBCOLUM4,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,
 var_generalTable, 3,  { 11 , 1, 4 }},
};
/*    (L = length of the oidsuffix) */


/** Initializes the exampleObject module */
void
init_exampleObject(void)
{

    DEBUGMSGTL(("exampleObject", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("exampleObject", exampleObject_variables, variable4,
               exampleObject_variables_oid);

    /* place any other initialization junk you need here */
}

/*
 * var_exampleObject():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_exampleObject(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;

    if (header_generic(vp,name,length,exact,var_len,write_method)
                                  == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case EXAMPLEOBJECT1:
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case EXAMPLEOBJECT2:
        *write_method = write_exampleObject2;
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case EXAMPLEOBJECT3:
        *write_method = write_exampleObject3;
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case EXAMPLEOBJECT4:
        *write_method = write_exampleObject4;
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    default:
      ERROR_MSG("");
    }
    return NULL;
}


/*
 * var_simpleTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_exampleObject above.
 */
unsigned char *
var_simpleTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, TABLE_SIZE)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case SIMPLETBCOLUM1:
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case SIMPLETBCOLUM2:
        *write_method = write_simpleTbColum2;
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    default:
      ERROR_MSG("");
    }
    return NULL;
}
/*
 * var_generalTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_exampleObject above.
 */
unsigned char *
var_generalTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;

    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, TABLE_SIZE)
                                                == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case GENERALTBCOLUM1:
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case GENERALTBCOLUM2:
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case GENERALTBCOLUM3:
        *write_method = write_generalTbColum3;
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    case GENERALTBCOLUM4:
        *write_method = write_generalTbColum4;
        VAR = VALUE;	/* XXX */
        return (u_char*) &VAR;
    default:
      ERROR_MSG("");
    }
    return NULL;
}



int
write_exampleObject2(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to exampleObject not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to exampleObject: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_exampleObject3(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to exampleObject not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to exampleObject: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_exampleObject4(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to exampleObject not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to exampleObject: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_simpleTbColum2(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to exampleObject not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to exampleObject: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_generalTbColum3(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to exampleObject not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(char)) {
              fprintf(stderr,"write to exampleObject: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_generalTbColum4(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to exampleObject not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to exampleObject: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

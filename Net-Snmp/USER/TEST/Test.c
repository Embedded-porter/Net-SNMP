/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "a.h"

/** Initializes the a module */
void init_a(void)
{
    const oid test_oid[] = {1, 3, 6, 1, 4, 1, 1, 1, 1};

    DEBUGMSGTL(("a", "Initializing\n"));

    /*注册一个标量OID的句柄到系统句柄链表中,也就是放入snmp系统中*/
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("test",               // 名字
                                            handle_test,          // 处理回调函数
                                            test_oid,             // 待注册的OID
                                            OID_LENGTH(test_oid), // OID长度
                                            HANDLER_CAN_RWRITE    // 读写权限
                                            ));
}

int handle_test(netsnmp_mib_handler *handler,
                netsnmp_handler_registration *reginfo,
                netsnmp_agent_request_info *reqinfo,
                netsnmp_request_info *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    int value = 10;
    int setValue;
    switch (reqinfo->mode)
    {

    case MODE_GET: // 获取OID节点的值,需要用户在改步骤实现数据返回,包括数据类型和数据长度
        snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                 &value /*添加读取的内容*/ /* XXX: a pointer to the scalar's data */,
                                 4 /*内容长度*/ /* XXX: the length of the data in bytes */);
        break;

    /*
     * SET REQUEST
     *
     * multiple states in the transaction.  See:
     * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
     */
    case MODE_SET_RESERVE1:  //设置预处理步骤1,主要用于检查设置值的有效性,比如值的大小和类型
        /* or you could use netsnmp_check_vb_type_and_size instead */
        ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
        if (ret != SNMP_ERR_NOERROR)
        {
            netsnmp_set_request_error(reqinfo, requests, ret);
        }
        break;

    case MODE_SET_RESERVE2:   //设置预处理步骤2,如果有需要可以在此分配必要的内存空间和保存旧值
        /* XXX malloc "undo" storage buffer */
        if (0 /*这里填出错的条件*/)
        {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
        }
        break;

    case MODE_SET_FREE:  //设置失败,释放内存
        /* XXX: free resources allocated in RESERVE1 and/or
           RESERVE2.  Something failed somewhere, and the states
           below won't be called. */
        break;

    case MODE_SET_ACTION: // 执行设置命令,写入到值的内存中
        // 获取设置的值,其他类型的数据可以到net-snmp官网看requests结构体的成员
        setValue = *requests->requestvb->val.integer;
        printf("setvalue:%d\n", setValue);
        if (0 /*这里填错误条件*/)
        {
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE /*报错的宏,snmp官网可查*/);
        }
        break;

    case MODE_SET_COMMIT:  //表示已经设置成功,可以释放资源
        /* XXX: delete temporary storage */
        if (0 /*出错条件*/)
        {
            /* try _really_really_ hard to never get to this point */
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
        }
        break;

    case MODE_SET_UNDO:
        /* XXX: UNDO and return to previous value for the object */
        if (0 /*出错条件*/)
        {
            /* try _really_really_ hard to never get to this point */
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
        }
        break;

    default:
        /* we should never get here, so this is a really bad error */
        snmp_log(LOG_ERR, "unknown mode (%d) in handle_test\n", reqinfo->mode);
        return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

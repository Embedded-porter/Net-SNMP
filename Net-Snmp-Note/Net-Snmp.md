# SNMP

## 移植和mib2c的使用

1. 下载源码http://www.net-snmp.org/download.html，下面使用net-snmp-5.7.3版本介绍

2. tar -zxvf net-snmp-5.7.3.tar.gz

3. 进入net-snmp-5.7.3目录

4. 配置`.configure`

    ```ASN.1
    sudo ./configure  --prefix=/usr/local/snmp --with-default-snmp-version="3" --with-sys-contact="contact@contact" --with-sys-location="location" --with-logfile=/var/log/snmpd.log  --with-persistent-directory=/var/net-snmp     --在虚拟机中使用，先不添加mib库
    
    sudo ./configure --host=arm-linux --target=arm --with-cc=arm-linux-gnueabihf-gcc --with-ar=arm-linux-ar --with-endianness=little --enable-mini-agent --prefix=/usr/local/snmp --with-default-snmp-version="2" --with-sys-contact="contact@contact" --with-sys-location="location" --with-logfile="/var/log/snmpd.log" --with-persistent-directory="/var/net-snmp"     --在开发板上使用，先不添加mib库
    ```
    
4. ![image-20231123095203841](./.assets/image-20231123095203841-1700704326023-7.png)

5. 先执行`make clean`,然后在执行`make`

6. 执行`sudo make install`，进行安装

7. **报错处理**

    1. snmpd: error while loading shared libraries: libnetsnmpagent.so.25: cannot open shared object file: No such file or directory
        **解决方法：export LD_LIBRARY_PATH=/usr/local/snmp/lib 或vi /etc/profile 在最后一行加入：export LD_LIBRARY_PATH=/usr/local/snmp/lib**

    2. 没有perl库问题：/usr/bin/ld: cannot find -lperl
        解决方法：**sudo apt-get install libperl-dev 或者 执行./configure配置时跟上–disable-embedded-perl参数，不安装此库，mib2c工具不能使用**
        也许还会碰到缺少 libtool,openssl,zlib库的情况，请直接安装。
        一般遇到这种缺少了什么库的问题，都是通过安装libXXX-dev或者安装XXX-dev来解决。但也不绝对，有的时候是因为相关的库不是安装在系统的默认路径，也没用加入到环境变量中

8. ![image-20231122173712156](./.assets/image-20231122173712156.png)

    ```
    文件夹说明：
    		bin: snmp自带工具，主要是mib2c自动生成文件工具
    		etc: 配置文件夹
    		include: snmp头文件
    		lib: snmp依赖文件
    		sbin: snmpd代理
    		share: 重点是mibs库
    ```

    

9. 使用`ls`命令查看/usr/local/snmp目录下是否存在etc目录，如果不存在使用’mkdir etc’在该目录下新建文件夹etc，将snmp源码目录下的EXAMPLE.conf文件拷贝到/usr/local/snmp/etc文件夹下"cp EXAMPLE.conf /usr/local/snmp/etc/snmpd.conf"

10. 修改snmp.conf文件

    ```c
    1）agentAddress udp:127.0.0.1:161修改为agentAddress udp:161
    2) 将trapsink localhost public行注释
    3) 将trap2sink localhost public行取消注释
    4) 将rocommunity public default -V systemmonly修改为rwcommunity public default
    ```

12. 运行snmpd代理

       ```
       执行命令： /usr/local/snmp/sbin/snmpd -c /usr/local/snmp/etc/snmpd.conf    --运行snmpd代理程序，-c用于链接配置文件
       执行命令：  snmpd -Dread_config -H 2>&1 | grep "Reading"|sort -u:查看从哪里读取snmpd.conf配置文件
       查看命令：snmpd -f -Lo -Dread_config
       启动命令：./snmpd -Lo -f
       ```

12. 配置snmp工具的使用路径，这样子系统才能找到mib2c工具

     ```
     export LD_LIBRARY_PATH=/usr/local/snmp/lib    或    vi /etc/profile 在最后一行加入：export LD_LIBRARY_PATH=/usr/local/snmp/lib
     ```

13. 测试一下系统是否已经可以找到snmp的工具链![image-20231123083840264](./.assets/image-20231123083840264.png)

14. 将写好的mib库（可以自己写，也可以使用MIB builder软件生成）移动到`/usr/local/snmp/share/snmp/mibs`目录下，后缀可以是 XXX.txt或者XXX.mib

     ```ASN.1
     --
     -- OTS3000-C2-OPMV2.my
     -- MIB generated by MG-SOFT Visual MIB Builder Version 6.0  Build 88
     -- Monday, June 13, 2016 at 13:41:13
     --
     
     --  OTS3000-C2-OPMV2.my
     -- MIB generated by MG-SOFT Visual MIB Builder Version 6.0  Build 88
     -- Monday, June 13, 2016 at 11:48:18
     -- 
     --  MG-SOFT Corporation root SMI
     -- 
     -- Copyright (C) 1995, 1998 by MG-SOFT Corporation.
     -- All rights reserved.
     -- 
     -- Comments to: <info@mg-soft.si>
     -- Web URL: http://www.mg-soft.si/
     -- 
     
     	TEST-MIB DEFINITIONS ::= BEGIN
      
     		IMPORTS
     			enterprises, Integer32, OBJECT-TYPE, MODULE-IDENTITY			
     				FROM SNMPv2-SMI			
     			TEXTUAL-CONVENTION			
     				FROM SNMPv2-TC;
     	
     	
     --  1.3.6.1.4.1.40989
     -- November 24, 1998 at 01:00 GMT
     -- May 08, 2015 at 17:01 GMT
     		-- 1.3.6.1.4.1.40989
     		glsun MODULE-IDENTITY 
     			LAST-UPDATED "199811240100Z"		-- November 24, 1998 at 01:00 GMT
     			ORGANIZATION 
     				"MG-SOFT Corporation"
     			CONTACT-INFO 
     				"MG-SOFT Corporation
     				Strossmayerjeva 32A
     				2000 Maribor
     				Slovenia
     				
     				Phone:  +386 62 2295050
     				Fax:    +386 62 2295051
     				Web:    http://www.mg-soft.si/
     				E-Mail: info@mg-soft.si"
     			DESCRIPTION 
     				"MG-SOFT Corporation root MIB module."
     			REVISION "201505081701Z"		-- May 08, 2015 at 17:01 GMT
     			DESCRIPTION 
     				"OAP MIB FILE"
     			::= { enterprises 40989 }
     
     		
     	
     --
     -- Textual conventions
     --
     	
     		OpticalPower ::= TEXTUAL-CONVENTION
     			STATUS current
     			DESCRIPTION 
     				"Description."
     			SYNTAX Integer32
     
     	
     --
     -- Node definitions
     --
     	
     --  Node definitions
     -- 
     		-- 1.3.6.1.4.1.40989.10
     		device OBJECT IDENTIFIER ::= { glsun 10 }
     
     		
     		-- 1.3.6.1.4.1.40989.10.16
     		ost3000 OBJECT IDENTIFIER ::= { device 16 }
     
     		
     		-- 1.3.6.1.4.1.40989.10.16.2
     		card2 OBJECT IDENTIFIER ::= { ost3000 2 }
     
     		
     		-- 1.3.6.1.4.1.40989.10.16.2.13
     		opdv2 OBJECT IDENTIFIER ::= { card2 13 }
     
     		
     		-- 1.3.6.1.4.1.40989.10.16.2.13.1
     		State OBJECT-TYPE
     			SYNTAX INTEGER
     				{
     				off(0),
     				on(1)
     				}
     			MAX-ACCESS read-only
     			STATUS current
     			DESCRIPTION
     				"Description."
     			::= { opdv2 1 }
     
     		-- 1.3.6.1.4.1.40989.10.16.2.13.24
     		c2CH1Wave OBJECT-TYPE
     			SYNTAX INTEGER
     				{
     				1310nm(0),
     				1550nm(1)
     				}
     			MAX-ACCESS read-write
     			STATUS current
     			DESCRIPTION
     				"Description."
     			::= { opdv2 2 }
     
     
     		-- 1.3.6.1.4.1.40989.10.16.2.13.72
     		AlarmStatus OBJECT-TYPE
     			SYNTAX INTEGER
     				{
     				alarm(0),
     				normal(1)
     				}
     			MAX-ACCESS read-only
     			STATUS current
     			DESCRIPTION
     				"Description."
     			::= { opdv2 3 }
     	END
     
     --
     -- OTS3000-C2-OPMV2.my
     --
     ```

     

15. 使用命令：`export MIBS=ALL `将导出全部的mibs中的库

16. 使用命令：` /usr/local/snmp/bin/snmptranslate -Tp -IR XXX-MIB::节点`,检测我们写的mib库格式是否正确(文件格式一定要是文本)

     ![image-20231123085235918](./.assets/image-20231123085235918.png)

17. 使用工具mib2c生成代码：`env MIBS="+/usr/local/snmp/share/snmp/mibs/XXX-MIB.txt" /usr/local/snmp/bin/mib2c 节点`（说明：mib2c工具支持的格式：XX.txt、XXX.mib、XXX.my）![image-20231123090725974](./.assets/image-20231123090725974-1700703593592-1.png)

18. 生成的代码

     ```c
     /*
      * Note: this file originally auto-generated by mib2c using
      *        $
      */
     
     #include <net-snmp/net-snmp-config.h>
     #include <net-snmp/net-snmp-includes.h>
     #include <net-snmp/agent/net-snmp-agent-includes.h>
     #include "device.h"
     
     /** Initializes the device module */
     void
     init_device(void)
     {
         //工具mib库创建节点
         const oid State_oid[] = { 1,3,6,1,4,1,40989,10,16,2,13,1 };
         const oid c2CH1Wave_oid[] = { 1,3,6,1,4,1,40989,10,16,2,13,2 };
         const oid AlarmStatus_oid[] = { 1,3,6,1,4,1,40989,10,16,2,13,3 };
     
       DEBUGMSGTL(("device", "Initializing\n"));
     
         //节点处理回调函数
         netsnmp_register_scalar(
             netsnmp_create_handler_registration("State", handle_State,
                                    State_oid, OID_LENGTH(State_oid),
                                    HANDLER_CAN_RONLY
             ));
         netsnmp_register_scalar(
             netsnmp_create_handler_registration("c2CH1Wave", handle_c2CH1Wave,
                                    c2CH1Wave_oid, OID_LENGTH(c2CH1Wave_oid),
                                    HANDLER_CAN_RWRITE
             ));
         netsnmp_register_scalar(
             netsnmp_create_handler_registration("AlarmStatus", handle_AlarmStatus,
                                    AlarmStatus_oid, OID_LENGTH(AlarmStatus_oid),
                                    HANDLER_CAN_RONLY
             ));
     }
     
     int
     handle_State(netsnmp_mib_handler *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info   *reqinfo,
                               netsnmp_request_info         *requests)
     {
         /* We are never called for a GETNEXT if it's registered as a
            "instance", as it's "magically" handled for us.  */
     
         /* a instance handler also only hands us one request at a time, so
            we don't need to loop over a list of requests; we'll only get one. */
         int value
         switch(reqinfo->mode) {
         //获取节点数据
             case MODE_GET:
                 snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                         &value /* XXX: a pointer to the scalar's data */,
                                       sizeof(value)/* XXX: the length of the data in bytes */);
                 break;
     
             default:
                 /* we should never get here, so this is a really bad error */
                 snmp_log(LOG_ERR, "unknown mode (%d) in handle_State\n", reqinfo->mode );
                 return SNMP_ERR_GENERR;
         }
         return SNMP_ERR_NOERROR;
     }
     int
     handle_c2CH1Wave(netsnmp_mib_handler *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info   *reqinfo,
                               netsnmp_request_info         *requests)
     {
         int ret;
         /* We are never called for a GETNEXT if it's registered as a
            "instance", as it's "magically" handled for us.  */
     
         /* a instance handler also only hands us one request at a time, so
            we don't need to loop over a list of requests; we'll only get one. */
         int Wave;
         int WaveStatus;
         switch(reqinfo->mode) {
             //获取节点数据
             case MODE_GET:
                 snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                         &WaveStatus/* XXX: a pointer to the scalar's data */,
                                         sizeof(WaveStatus)/* XXX: the length of the data in bytes */);
                 break;
     
             /*
              * SET REQUEST
              *
              * multiple states in the transaction.  See:
              * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
              */
             case MODE_SET_RESERVE1:
                     /* or you could use netsnmp_check_vb_type_and_size instead */
                 ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
                 if ( ret != SNMP_ERR_NOERROR ) {
                     netsnmp_set_request_error(reqinfo, requests, ret );
                 }
                 break;
     
             case MODE_SET_RESERVE2:
                 /* XXX malloc "undo" storage buffer */
                 if (Wave != 0 || Wave != 1) {
                     netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
                 }
                 break;
     
             case MODE_SET_FREE:
                 /* XXX: free resources allocated in RESERVE1 and/or
                    RESERVE2.  Something failed somewhere, and the states
                    below won't be called. */
                 break;
             //这里是设置节点的值，我们这里只是打印一下要设置的值，实际根据业务情况进行处理
             //获取设置的值,其他类型的数据可以到net-snmp官网看requests结构体的成员
             case MODE_SET_ACTION:
                  Wave = *requests->requestvb->val.integer;
                  printf("setvalue:%d\n", Wave);
                 if (0/* XXX: error? */) {
                     netsnmp_set_request_error(reqinfo, requests, /* some error */);
                 }
                 break;
     
             case MODE_SET_COMMIT:
                 /* XXX: delete temporary storage */
                 if (/* XXX: error? */) {
                     /* try _really_really_ hard to never get to this point */
                     netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
                 }
                 break;
     
             case MODE_SET_UNDO:
                 /* XXX: UNDO and return to previous value for the object */
                 if (/* XXX: error? */) {
                     /* try _really_really_ hard to never get to this point */
                     netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
                 }
                 break;
     
             default:
                 /* we should never get here, so this is a really bad error */
                 snmp_log(LOG_ERR, "unknown mode (%d) in handle_c2CH1Wave\n", reqinfo->mode );
                 return SNMP_ERR_GENERR;
         }
     
         return SNMP_ERR_NOERROR;
     }
     int
     handle_AlarmStatus(netsnmp_mib_handler *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info   *reqinfo,
                               netsnmp_request_info         *requests)
     {
         /* We are never called for a GETNEXT if it's registered as a
            "instance", as it's "magically" handled for us.  */
     
         /* a instance handler also only hands us one request at a time, so
            we don't need to loop over a list of requests; we'll only get one. */
         
         switch(reqinfo->mode) {
     
             case MODE_GET:
                 snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                          /* XXX: a pointer to the scalar's data */,
                                          /* XXX: the length of the data in bytes */);
                 break;
     
     
             default:
                 /* we should never get here, so this is a really bad error */
                 snmp_log(LOG_ERR, "unknown mode (%d) in handle_AlarmStatus\n", reqinfo->mode );
                 return SNMP_ERR_GENERR;
         }
     
         return SNMP_ERR_NOERROR;
     }
     ```

19. 生成的文件中`XX`的位置就是你要添加自己的业务![image-20231123091739027](./.assets/image-20231123091739027.png)
20. 将生成的代码放到TEST文件夹下，然后拷贝文件夹到net-snmp源码目录的agent/mibgroup/目录下，进行编译，配置命令如下

21. 执行make clean后在执行make执行完毕后在执行make install进行安装

22. 相关编译选项和库文件相关内容命令

    ```
    net-snmp-config --cflags :安装编译选项
    net-snmp-config --agent-libs :代理开发库路径
    net-snmp-config --libs : 基于Net-SNMP库开发需要用到的编译选项
    ```

## 移植开发板

1. 执行完毕将`/usr/local/snmp/sbin`中的可以执行程序snmpd移植到Linux开发板上即可（前提是你已经将snmp服务移植到开发板上）
2. 将make install生成目录下的sbin/snmpd 以及 share/snmp/mibs/ + snmpd.conf(修改过的)，打包为arm-net-snmp-5.7.3.tar，放到开发板上运行，要重新指定snmpd链接配置文件snmpd.conf (命令见：步骤12)

```c
c注：snmpd命令的有用选项
-c FILE 指定文件为配置文件
-C 不读取默认的配置文件
-d dump接收和发送SNMP数据包
-D TOKEN 对于给定的TOKEN（标志）打开调试信息 （ -Dmib_init）
-I [-]INITLIST 对于要初始化的MIB列表显示
-M DIRLIST 指定MIB库的路径
-V 显示详细信息
-Le 把错误信息输出到日志中
-Lf FILE 把错误信息输出到指定文件中
```

3. iptables 防火墙对外开放udp:161端口访问权限，snmp要使用161端口

```
iptables -I INPUT -p udp --dport 161 -j ACCEPT	设置指令
iptables -L   查看指令
lsof -i:161 :查看端口
netstat -lnp | grep snmpd : 列出所有与 snmpd 进程相关的正在监听的网络连接及其对应的进程信息
netstat -an | grep 161  :查看端口情况
netstat -aon|findstr 161 :widows下查看端口占用
ps -e 查看所有进程
net-snmp-config:查看配置命令
iostat 查看系统IO状态
```

## snmpd.conf配置文件的分析

1. agentaddress命令用于定义协议和监听地址

    ```c
    agentaddress udp:161,tcp:1611,udp6:161,tcp6:1611
    ```

2. 基于系统安全的考虑，可以指定代理在某个用户组和用户下运行

    ```c
    agentgroup snmp  //用户组
    agentuser nobody //用户
    ```

3. 优化性能查询，可以配置单个变量最大绑定数和最大响应数

    ```c
    maxGetbulkRepeats    2  // 最大Getbulk重复次数）用于控制SNMP管理器在执行GetBulk操作时重复获取变量的次数
    maxGetbulkResponses  10 // 最大Getbulk响应数）用于控制SNMP代理在执行GetBulk操作时返回的最大响应数据包的数量
    ```

4. 系统监控配置

    ```c
    proc  init 1 1  //确保系统最少有一个线程
     
    proc  httpd   //最少一个httpd在运行
    procfix httpd /etc/rc.d/init.d/httpd restart //如果检测到没有httpd没有运行时重新启动   如果没有配置则会产生noSuchObject错误
        
    disk  / 30% //磁盘监控，当系统的磁盘少于30%的时候，会产生错误
        
    load  7 6 5 //负载监控
        
    file  /var/log/snmpd.log 1024 //文件大小的监控
    ```

5. 主动监控，理论上代理端是等待管理发送请求命令之后做出反应的，那个也可以使用主动监控，主动发送trap

    ```c
    trapsink  192.168.166.196    [端口]   // SNMPv1 and   SNMPV2  trap receiver ip  
    trap2sink  192.168.166.196   [端口]   // SNMPv2 and SNMPV3 trap receiver ip
    informsink  192.168.166.196  [端口]   //用于配置SNMP代理接收SNMP v2c和SNMP v3版本的通知（inform）。通知（inform）是一种与陷阱类似的消息，但它要求接收方向发送回一个确认消息 
    ```

6. 分布式管理：实现这些MIB的设备能够实现自我的监控邻里监控，并以通告的方式报告异常

    ```c
    monitor [OPTIONS] NAME EXPRESSION //触发Trap的配置命令
    /*定义一个监控的MIB对象，该对象的值满足表达式EXPRESSION时触发一次通告或SET请求。EXPRESSION支持3种类型的监控事件：OID是否存在测试（Existence）、布尔测试（Boolean）、阈值测试（Threshold）*/
    例子：monitor -u MD5_User -o hrSWRunName "high process memory" hrSWRunPerfMem > 10000 //监控所有进程内存使用，当内存大于10MB时绑定hrSWRunName和用户MD5_User发送Trap（DisMan trap mteTriggerFired）
        
    /*两种监控计划: 周期性  定时性*/
    repeat FREQUENCY OID = VALUE 			    //周期性的：表示每隔FREQUENCY秒将VALUE（整型数）赋值到OID
    at MINUTE HOUR DAY MONTH WEEKDAY OID = VALUE //定时性：表示在具体的时间点执行设置操作
    
    /*例子：*/
    /*周期读取配置文件：每小时读取配置文件*/
    repeat 3600 versionUpdateConfig.0 = 1
    /* 也可以在指定时刻读取配置文件*/
    cron 31 17 20 12 52 versionUpdateConfig.0 = 1
    ```

7. VACM

    >  SNMP v3中的安全机制主要由两部分实现：安全模型、安全传输

    1. 安全模型：

        ```C
        USM（User-based Security Model，基于用户的安全模型）
        VACM（View Access Control Model，基于视图的访问控制模型）
        TSM（Transport Security Model，基于传输的安全模型，其实现了证书签名认证的机制）
        KSM（kerberos-based SNMP security Model，基于kerbreos的SNMP安全模型）
        ```

    2. 安全传输

        ```c
        安全传输模块有UDP/UDPIP v6、TCP/TCPIP v6、TLS/DTLS、SSH、Kerberos等。这些模块有的是默认配置，有的需要读者自行配置进去
        ```

    > VACM提供了精确控制MIB访问的机制，可明确"谁"以什么样的方式和拥有什么权限来访问那些OID！！！！！

    例子：

    ```cmake
    #-----------------------------配置----------------------------------------#
    
    #-----------------------------第一步----------------------------------------#
    #创建了两个安全名sec.name, 第一个名为local，指定其访问来源为localhost，
    #即本机,其访问口令是secret42;第二个名为custom_sec，其访问来源限定为子网192.168.1.0/24,访问口令是public.
    
    #       sec.name  		 source          community
    com2sec  local     		localhost         secret42
    com2sec  custom_sec 	 default           public
    
    #createUser               username [-e ENGINEID] (MD5|SHA) authpassphrase [DES [privpassphrase]]
    #create snmpv3 user
    rwuser glsun
    createUser glsun MD5 "glsun@0773" DES "glsun@0773" # 验证和密码都是glsun,这个放到/var/net-snmp/snmpd.conf
    
    
    #-----------------------------第二步----------------------------------------#
    #将安全名sec.name根据不同的安全模型sec.model创建分组
    group  MyRWGroup v1          local
    group  MyRWGroup v2c         local
    
    group custom_grp v1         custom_sec
    group custom_grp v2c        custom_sec
    
    group incremental usm       glsun 
    
    #-----------------------------第三步----------------------------------------#
    #创建不同的OID视图，即不同的子树
    view all included .1            
    
    view custom_v excluded  .1              
    view custom_v included  sysUpTime.0
    view custom_v included  hrStorageTable
    #              incl/excl  subtree     mask
    view mini_view excluded .1 80
    view mini_view included  sysUpTime.0
    
    view if_view excluded .1 80
    view if_view included  sysUpTime.0
    view if_view included  ifTable
    
    #-----------------------------第三步----------------------------------------#
    #最后，根据不同的安全等级赋予group不同的可访问OID视图
    #            组        上下文              安全模型               安全等级             读           写     发送通知权限
    # access    GROUP     CONTEXT    {anylv1/v2c|usm / tsm / ksm}    LEVEL     PREFX    READ        WRITE      NOTTFY
    access     MyRWGroup     ""                  v1                  noauth    exact     all         none       none
    access     MyRWGroup     ""                  v2c                 noauth    exact   if_view       none       none
    access     custom_grp    ""                  v1                  noauth    exact   mini_view     none       none
    access     custom_grp    ""                  v2c                 noauth    exact   custom_v      none       none
    
    access     incremental   ""                  usm                 noauth    exact   mini_view     none       none
    access     incremental   ""                  usm                  auth     exact   custom_v      none       none
    access     incremental   ""                  usm                  priv     exact     all         none       none
    
    #-----------------------------结果----------------------------------------#
    #上面的配置中，本地用户(MyRWGroup)在SNMP v1模式下，能够访问所有OID树；在v2c模式下，仅能访问IF-MIB::ifTable中数据.
    # 默认来源用户(custom_grp)，即所有用户在SNMPv1模式下仅能得到sysUpTime.0的数据，在SNMPv2c模式下，能够访问sysUpTime.0和
    #hrStorageTable中数据; usm模式下，noauth安全等级下，用户(cici)仅能访问sysUpTime.0的数据，
    #auth安全等级下，能够访问sysUpTime.0和hrStorageTable数据，priv安全等级下，能够访问所有的OID树
    ```

## 常用工具

### 协议操作工具



![image-20231221092347223](./.assets/image-20231221092347223.png)

![image-20231221092401306](./.assets/image-20231221092401306.png)

```
链接的snmpd.conf:
			   rwuser MD5_DES_User_1 authpriv system
			   rwuser MD5_DES_User_2 authpriv system
			   rouser noAuth_User noauth system
			   rouser MD5_User authNoPriv  system
			   
/var/net-snmp/snmpd.conf（持久数据信息）:
			   createUser noAuth_User
			   createUser MD5_User MD5 "glsun@0773"
			   createUser MD5_DES_User_1  MD5 "glsun@MD5" DES    # 验证密码和加密密码一致:"glsun@MD5"
			   createUser MD5_DES_User_2  MD5 "glsun@MD5" DES "glsun@DES" # 	   

测试指令
			  snmpgetnext -v 3 -n "" -u noAuth_User  -l NoauthNoPriv localhost sysUpTime.0
			  snmpgetnext -v 3 -n "" -u MD5_User -a MD5 -A "glsun@0773" -l authNoPriv localhost sysUpTime.0   
			  snmpgetnext -v 3 -n "" -u MD5_DES_User_1 -a MD5 -A "glsun@MD5" -x DES -X "glsun@MD5" -l authPriv localhost sysUpTime.0   
			  snmpgetnext -v 3 -n "" -u MD5_DES_User_2 -a MD5 -A "glsun@MD5" -x DES -X "glsun@MD5" -l authPriv localhost sysUpTime.0  
```

### 信息收集和查看工具

1. **snmpdf：**用于监控Agent磁盘的使用情况

    ```
    执行：
    	snmpdf -v 2c -c public localhost
    
    回复:
    	Description              Size (kB)            Used       Available Used%
    	Physical memory            8144452         5964948         2179504   73%
    	Virtual memory             9142848         5964948         3177900   65%
    	Memory buffers             8144452          335728         7808724    4%
    	Cached memory              4093968         4093968               0  100%
    	Shared memory                33820           33820               0  100%
    	Swap space                  998396               0          998396    0%
    	/                        174342888        20425728       153917160   11%
    	/run                        814448            9672          804776    1%
    	/dev/shm                   4072224             288         4071936    0%
    	/run/lock                     5120               4            5116    0%
    	/sys/fs/cgroup             4072224               0         4072224    0%
    	/run/user/1000              814448              64          814384    0%
    ```

2. **snmpstatus：**监控代理系统信息，包括系统描述，系统启动的时长，收发的包数等等情况

    ```
    执行：
    	snmpstatus -v 2c -c public localhost
    
    系统答复：
    		[UDP: [127.0.0.1]:161->[0.0.0.0]:33170]=>[Linux molin-virtual-machine 4.15.0-29-generic #31~16.04.1-Ubuntu SMP Wed Jul 18 			08:54:04 UTC 2018 x86_64] Up: 0:48:34.35Interfaces: 2, Recv/Trans packets: 23170652/1432488 | IP: 6246010/1384407
    ```

3. **snmptranslate：**可以用于验证是否正确的加载MIB文件，以字符或者数字的方式查看OID

    ```
    执行：
    	snmptranslate -Onf -IR sysDescr
    
    回复：
    	.iso.org.dod.internet.mgmt.mib-2.system.sysDescr
    
    执行：
    	snmptranslate -On -IR sysDescr	
    回复：
    	.1.3.6.1.2.1.1.1
    	
    执行：snmptranslate -Td -OS .1.3.6.1.2.1.1.1   #查看OID详情
    
    回复：
    	SNMPv2-MIB::sysDescr
    	sysDescr OBJECT-TYPE
      	-- FROM       SNMPv2-MIB
     	-- TEXTUAL CONVENTION DisplayString
     	SYNTAX        OCTET STRING (0..255)
     	DISPLAY-HINT  "255a"
     	MAX-ACCESS    read-only
     	STATUS        current
      	DESCRIPTION   "A textual description of the entity.  This value should
                include the full name and version identification of
                the system's hardware type, software operating-system,
                and networking software."
    	::= { iso(1) org(3) dod(6) internet(1) mgmt(2) mib-2(1) system(1) 1 }
    ```

### 配置工具

> 配置工具主要完成代理运行环境、运行参数、辅助功能等的配置，包括配置管理对象获取权限、系统监控、代理角色、TRAP发送地址、SNMP v3用户名密码等。所以，正确地进行配置是代理运行的根本保障，当snmpd无法找到正确的配置文件时将无法启动

1. **snmpconf：**用于创建snmpd.conf配置文件，通过一问一答的perl脚本来创建(通过二进制源码编译的过程是不会产生现成的配置文件snmpd.conf,得执行命令` snmpconf -g basic_setup`来生成配置文件，当然也可以直接复制二进制源码包的配置文件，然后进行修改)

    ```
    指令格式：
    	    snmpconf [option]  [fileToCreate]
    常用option：
    		 -f（强制重写配置文件）
    		 -i(生成的配置文件自动放到snmpd配置系统目录中)
    		 -I（指定生成存放的目录）
    		 -a(读取配置文件中的内容并且自动生成注释，同时写入到指定的文件)
    		 -R（读取配置文件）
    例子：
    	snmpconf -R /usr/local/snmp/snmpd.conf -a -f snmpd.conf（读取“/usr/local/snmp/snmpd.conf”文件的有效内容（标记），自动添加注释后，写入到当前目录下的snmpd.conf文件中）
    ```

2. **net-snmp-config：**用来查看Net-SNMP安装的库和二进制程序的相关信息，具体可以通过命令`net-snmp-config -h`来查看

    ```
    常用选项：
    	   net-snmp-config --snmpconfpath(查看系统配置文件的搜索路径)
    	   net-snmp-config --default-mibdirs(查看系统MIB搜索的路径)
    	   net-snmp-config --persistent-directory(查看永久文件的搜索路径)
    	   net-snmp-config --perlprog(查看perl安装的路径)
    	   net-snmp-config -prefix（安装路径）
    	   net-snmp-config --configure-options(配置选项)
    	   net-snmp-config --snmpd-module-list(查看已编译的模块列表)
    ```

### 权限配置工具

1. **snmpusm：**管理SNMPV3用户工具，包括用户的创建，复制，删除，更改等

2. **snmpvacm：**用于创建和控制基于视图的访问控制![image-20231221141906009](./.assets/image-20231221141906009.png)

    

##  管理端开发

### 通信流程

1. 初始化Net-snmp库系统
2. 设置通信用户信息：用户名  版本 鉴权信息  密码等等
3. 开启snmp会话（开启和绑定传输层(TCP/UDP),建立会话,返回会话句柄）
4. 添加MIB：snmp会话开启相关mib库会添加到系统mib
5. 创建PDU和填充OID：可以绑定多个OID，对应获取消息，OID可以填NULL，对于设置类命令，则要填充要设置的值
6. 发送请求：通过已经建立的会话发送PDU
7. 接收返回到的包，获取其中的值
8. 处理接收到的信息，重要是业务逻辑的处理

### 主要的数据结构体

#### typedef struct snmp_pdu

```c
typedef struct snmp_pdu {

#define non_repeaters	errstat
#define max_repetitions errindex

    /*
     * Protocol-version independent fields
     */
    /** snmp version */
    long            version; 
    /** Type of this PDU */	
    int             command;
    /** Request id - note: not incremented on retries */
    long            reqid;  
    /** Message id for V3 messages note: incremented for each retry */
    long            msgid;
    /** Unique ID for incoming transactions */
    long            transid;
    /** Session id for AgentX messages */
    long            sessid;
    /** Error status (non_repeaters in GetBulk) */
    long            errstat;
    /** Error index (max_repetitions in GetBulk) */
    long            errindex;       
    /** Uptime */
    u_long          time;   
    u_long          flags;

    int             securityModel;
    /** noAuthNoPriv, authNoPriv, authPriv 安全模型和安全级别 */ 
    int             securityLevel;  
    int             msgParseModel;

    /**
     * Transport-specific opaque data.  This replaces the IP-centric address
     * field.  
     */
    
    void           *transport_data;          /*传输数据*/
    int             transport_data_length;   /*传输数据长度*/

    /**
     * The actual transport domain.  This SHOULD NOT BE FREE()D.  
     * 实际传输域 .比如UDP和TCP
     */

    const oid      *tDomain;  
    size_t          tDomainLen;

    netsnmp_variable_list *variables;  /*变量绑定列表*/


    /*
     * SNMPv1 & SNMPv2c fields
     * V1 和 V2c 协议消息
     */
    /** community for outgoing requests. */
    u_char         *community;      /*共同体字符串*/
    /** length of community name. */
    size_t          community_len;  

    /*
     * Trap information Trap消息
     */
    /** System OID */
    oid            *enterprise;     
    size_t          enterprise_length;
    /** trap type */
    long            trap_type;
    /** specific type  特定类型 */
    long            specific_type;
    /** This is ONLY used for v1 TRAPs  */
    unsigned char   agent_addr[4];    /*代理地址*/

    /*
     *  SNMPv3 fields
     */
    /** context snmpEngineID */
    u_char         *contextEngineID;
    /** Length of contextEngineID */
    size_t          contextEngineIDLen;     
    /** authoritative contextName */
    char           *contextName;
    /** Length of contextName */
    size_t          contextNameLen;
    /** authoritative snmpEngineID for security */
    u_char         *securityEngineID;
    /** Length of securityEngineID */
    size_t          securityEngineIDLen;    
    /** on behalf of this principal */
    char           *securityName;
    /** Length of securityName. */
    size_t          securityNameLen;        
    
    /*
     * AgentX fields
     *      (also uses SNMPv1 community field)
     */
    int             priority;
    int             range_subid;
    
    void           *securityStateRef;
} netsnmp_pdu;
```

#### struct snmp_session

```c
struct snmp_session {
    /*
     * Protocol-version independent fields
     */
    /** snmp version */
    long            version;
    /** Number of retries before timeout. */
    int             retries;  /*超时次数*/
    /** Number of uS until first timeout, then exponential backoff */
    long            timeout;    
    u_long          flags;
    struct snmp_session *subsession; 
    struct snmp_session *next;

    /** name or address of default peer (may include transport specifier and/or port number) */
    char           *peername;
    /** UDP port number of peer. (NO LONGER USED - USE peername INSTEAD) */
    u_short         remote_port;
    /** My Domain name or dotted IP address, 0 for default */
    char           *localname; /* 域名或者IP */
    /** My UDP port number, 0 for default, picked randomly */
    u_short         local_port;     
    /**
     * Authentication function or NULL if null authentication is used 
     */
    u_char         *(*authenticator) (u_char *, size_t *, u_char *, size_t);
    /** Function to interpret incoming data */
    netsnmp_callback callback;      
    /**
     * Pointer to data that the callback function may consider important 
     */
    void           *callback_magic;
    /** copy of system errno */
    int             s_errno;
    /** copy of library errno */
    int             s_snmp_errno;   
    /** Session id - AgentX only */
    long            sessid; 

    /*
     * SNMPv1 & SNMPv2c fields
     */
    /** community for outgoing requests. */
    u_char         *community;
    /** Length of community name. */
    size_t          community_len;  
    /**  Largest message to try to receive.  */
    size_t          rcvMsgMaxSize;
    /**  Largest message to try to send.  */
    size_t          sndMsgMaxSize;  

    /*
     * SNMPv3 fields
     */
    /** are we the authoritative engine? */
    u_char          isAuthoritative;    /*是否是认证引擎*/
    /** authoritative snmpEngineID */
    u_char         *contextEngineID;    /*上下为引擎ID*/
    /** Length of contextEngineID */
    size_t          contextEngineIDLen;     
    /** initial engineBoots for remote engine */
    u_int           engineBoots;       /*初始的远端引擎技术*/
    /** initial engineTime for remote engine */
    u_int           engineTime;
    /** authoritative contextName */
    char           *contextName;        /*认证上下文*/
    /** Length of contextName */
    size_t          contextNameLen;
    /** authoritative snmpEngineID */
    u_char         *securityEngineID;   /*安全引擎ID*/
    /** Length of contextEngineID */
    size_t          securityEngineIDLen;    
    /** on behalf of this principal */
    char           *securityName;
    /** Length of securityName. */
    size_t          securityNameLen;

    /** auth protocol oid */
    oid            *securityAuthProto;    /*认证OID*/
    /** Length of auth protocol oid */
    size_t          securityAuthProtoLen;
    /** Ku for auth protocol XXX */
    u_char          securityAuthKey[USM_AUTH_KU_LEN];       /*认证协议key*/
    /** Length of Ku for auth protocol */
    size_t          securityAuthKeyLen;
    /** Kul for auth protocol */
    u_char          *securityAuthLocalKey;       
    /** Length of Kul for auth protocol XXX */
    size_t          securityAuthLocalKeyLen;       

    /** priv protocol oid */
    oid            *securityPrivProto;
    /** Length of priv protocol oid */
    size_t          securityPrivProtoLen;
    /** Ku for privacy protocol XXX */
    u_char          securityPrivKey[USM_PRIV_KU_LEN];       
    /** Length of Ku for priv protocol */
    size_t          securityPrivKeyLen;
    /** Kul for priv protocol */
    u_char          *securityPrivLocalKey;       
    /** Length of Kul for priv protocol XXX */
    size_t          securityPrivLocalKeyLen;       

    /** snmp security model, v1, v2c, usm */
    int             securityModel;
    /** noAuthNoPriv, authNoPriv, authPriv */
    int             securityLevel;  
    /** target param name */
    char           *paramName;

    /**
     * security module specific 
     */
    void           *securityInfo;

    /**
     * transport specific configuration 
     */
   struct netsnmp_container_s *transport_configuration;

    /**
     * use as you want data 
     *
     *     used by 'SNMP_FLAGS_RESP_CALLBACK' handling in the agent
     * XXX: or should we add a new field into this structure?
     */
    void           *myvoid;
};
```

#### typedef struct variable_list

```c
typedef struct variable_list {
   /** NULL for last variable */
   struct variable_list *next_variable;    
   /** Object identifier of variable */
   oid            *name;   
   /** number of subid's in name */
   size_t          name_length;    
   /** ASN type of variable */
   u_char          type;   
   /** value of variable */
    netsnmp_vardata val;
   /** the length of the value to be copied into buf */
   size_t          val_len;
   /** buffer to hold the OID */
   oid             name_loc[MAX_OID_LEN];  
   /** 90 percentile < 40. */
   u_char          buf[40];
   /** (Opaque) hook for additional data */
   void           *data;
   /** callback to free above */
   void            (*dataFreeHook)(void *);    
   int             index;
} netsnmp_variable_list;
```

 ### 常用库-API接口

1. ASN1模块：主要是对MIB文件相关的ASN.1语法解析
2. MIB解析模块：MIB及相关数据类型操作函数
3. OID搜索和存储：负责OID相关的操作
4. 配置文件解析：主要是解析配置文件（重点！！！！）
5. 计时器模块：实现定时器和周期性执行回调函数
6. PDU模块：与PDU相关的函数，包括创建，释放等
7. 通用API：实现Net-SNMP的启动关闭，会话，通信，数据解析（重点！！！！）
8. 网络模块：实现SNMP核心网的功能
9. 安全模块：SNMP相关的安全机制
10. 日志模块：记录通信日志
11. 内存管理模块

#### 使用方法

> 主要包括以下三个头文件就可以实现全部的模块的API

1. 顶层的库头文件：` #include <net-snmp/net-snmp-includes.h>`：包含了所有模块的头文件
2. 顶层的配置文件：`#include <net-snmp/net-snmp-config.h>`：由系统配置自动生成，不要修改
3. 顶层代理头文件：`#include <net-snmp/net-snmp-config.h>`

### 测试例程

```c
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <string.h>

// 编译命令:gcc -g snmpdemoapp.c -L/usr/local/snmp/lib -lnetsnmp -lrt -lm -o snmpdemoapp

#define MAX_OID_LEN 128

int main(int argc, char **argv)
{
    int status;

    int count = 1;

    /*session:填充准备会话的信息
     *ss:记录返回的会话信息
     */
    netsnmp_session session, *ss;

    /*pdu 记录了远程主机的所有的信息*/
    netsnmp_pdu *pdu;
    /*response 记录了远程主机返回的PUD信息*/
    netsnmp_pdu *response;

    /*记录OID节点位置信息*/
    oid anOID[MAX_OID_LEN];
    size_t anOID_len;

    /*变量绑定列表(list数据结构)*/
    netsnmp_variable_list *vars;

    /*初始化SNMP 始化互斥量、MIB 解析、传输层、调试信息的初始化、解析配置文件的初始化(netsnmp_ds_register_config)、
     * 各句柄的初始化;定时器的初始化、读取配置文件*/
    init_snmp("snmpdemoapp");

    /*session的初始化:初始化目的地址,snmp版本协议,认证机制等等*/
    snmp_sess_init(&session); /*初始化*/

    session.peername = strdup("localhost");            /*设置目标地址*/
    session.version = SNMP_VERSION_1;                  /*设置snmp协议版本*/
    session.community = "public";                      /*设置共用体*/
    session.community_len = strlen(session.community); /*设置共用体长度*/

    /*开启和绑定传输层(TCP/UDP),建立会话,返回会话句柄*/
    ss = snmp_open(&session); /*打开会话*/
    if (!ss)
    {
        snmp_sess_perror("snmpdemoapp", &session);
        exit(1);
    }
    /*创建指定类型的PDU 选择执行的操作 绑定准备通信的OID*/
    pdu = snmp_pdu_create(SNMP_MSG_GET);
    anOID_len = MAX_OID_LEN; /*设置节点OID的长度,建议不超过128*/

    /*此处read_objid / snmp_parse_oid的作用是检查oID的正确性，并赋予anoID正确的值,也就是最终请求的OID*/
    // read_objid("system.sysDescr.0", anOID, &anOID_len);
    //  if (!snmp_parse_oid(".1.3.6.1.2.1.1.1.0", anOID, &anOID_len))

    if (!snmp_parse_oid("system.sysDescr.0", anOID, &anOID_len))
    {
        snmp_sess_perror(".1.3.6.1.2.1.1.1.0", &session); 
        exit(1);
    }
    /*将OID绑定到PDU,同时赋予一个NULL值作为变量的绑定*/
    snmp_add_null_var(pdu, anOID, anOID_len);

    /*同步发送报文*/
    status = snmp_synch_response(ss, pdu, &response);

    /*处理返回的报文*/
    if (status == STAT_SUCCESS && response->errstat == SNMP_ERR_NOERROR)
    {
        for (vars = response->variables; vars; vars = vars->next_variable)
        {
            print_variable(vars->name, vars->name_length, vars);
            printf("Running count:%d\n", count++);
        }
        count = 1;
        
        for (vars = response->variables; vars; vars = vars->next_variable)
        {
            if (vars->type == ASN_OCTET_STR)
            {
                char *sp = (char *)malloc(1 + vars->val_len);
                memcpy(sp, vars->val.string, vars->val_len);
                sp[vars->val_len] = '\0';
                printf("value #%d is a string:%s\n", count++, sp);
                free(sp);
            }
            else
            {
                printf("value #%d is NOT a string\n", count++);
            }
        }
    }
    else
    {
        if (status == STAT_SUCCESS)
        {
            fprintf(stderr, "Error in packet\nReason: %s\n", snmp_errstring(response->errstat));
        }
        else if (status == STAT_TIMEOUT)
        {
            fprintf(stderr, "Timeout: No response from %s.\n", session.peername);
        }
        else
        {
            snmp_sess_perror("snmpdemoapp", ss);
        }
    }
    if (response)
    {
        snmp_free_pdu(response);    //释放资源
    }
    snmp_close(ss);
    return 0;
}
```

## 代理端开发

### 开发代理流程

1. 定义私有MIB
2. 私有mib2c生成代码框架
3. 添加业务代码
4. 编译私有MIB模块：动态、静态或子代理等模块开发
5. 配置snmpd.conf
6. 测试与调试
7. 发布

### mib2c框架

> 通过mib2c和代码框架配置文件生成MIB节点的.c和.h文件，添加业务功能就可以直接使用

1. MIB的注册
2. GET请求处理
3. STE请求处理

命令：`mib2c -c 框架  MIB节点`

```
mib2c -c mib2c.scalar.conf BOOK-EXAMPLE-MIB::exampleObject
```

**生成代码处理流程**

1. MODE_GET：获取OID节点的值；需要用户在该步骤实现数据返回。值的内存地址和值的占用空间的长度
2. MODE_SET_RESERVE1：设置流程预处理步骤一，用于检查设置值的有效性，如类型和大小，最大值、值域范围等
3. MODE_SET_RESERVE2：设置流程预处理步骤二，如果有需要的话可以在这个步骤中分配必要的内存空间和保存旧值
4. MODE_SET_FREE：当设置失败等错误时，释放步骤2），3）中涉及分到分配的内存
5. MODE_SET_ACTION：执行设置命令，写入设置值到内存中；如果有必要也可以在此处保存旧值
6. MODE_SET_COMMIT：到达该步骤时，说明已经设置成功，可以删除临时内存，旧值、记录设置日志等
7. MODE_SET_UNDO：回退步骤。如果设置对象后，由于系统产生错误需要回退到原始值时则执行该步骤。原始的值，往往就是保存在步骤2）或3）中分配的临时内存

**表格框架：iterate、iterate_access**

```
mib2c -c mib2c.iterate.conf BOOK-EXAMPLE-MIB::exampleObject			

mib2c -c mib2c.iterate_access.conf BOOK-EXAMPLE-MIB::exampleObject（推荐使用） 
iterate_access生成文件说明:
						exampleObject_checkfns.h：检查表格列的值和类型的函数声明
						exampleObject_checkfns_local.c：数据有效性检查函数的实现，需要用户自己实现
						exampleObject_columns.h：表格中的每列都定义为宏序号
						exampleObject_access.c：数据获取函数和迭代函数的实现
						exampleObject.c：模块主函数
						exampleObject_checkfns.c：数据有效性检查函数
						exampleObject_enums.h：如果MIB中有枚举类型，则定义相应的宏
						exampleObject_access.h：主要是迭代器声明
						exampleObject.h：模块中用到的头文件汇总、命令响应句柄声明
						exampleObject_checkfns_local.h：检查表格中可设置列的值和类型的函数声明
		   只需要修改文件：
		   				exampleObject_checkfns_local.h：检查表格中可设置列的值和类型的函数声明
						exampleObject_checkfns_local.c：数据有效性检查函数的实现，需要用户自己实现
						exampleObject_access.h：主要是迭代器声明
						exampleObject_access.c：数据获取函数和迭代函数的实现
```

